
 1. 浮动的元素，只能被有高度的盒子关住。也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。但是，工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。所以，我们就要找到，不给盒子加高度，但是也能清楚浮动的方法。

	 <div>  .. 设置height
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>

	 <div>  .. 设置height
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>

 2.最简单的清楚浮动的方法，就是给盒子增加clear:both ; 表示自己的内部元素，不受其他盒子的影响。
   但是这个margin 会失效，导致两个盒子之间没有空隙了
 	 <div> 
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>

	 <div>  .. claer:both
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>

 3.隔墙法
   在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。墙用自己的身体当做了间隙。
   隔墙法好用，但是第一个div，还是没有高度。

     <div> 
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>
	 
	 <div class="cl h10"></div>

	 <div> 
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>

 4.内墙法
   就是把隔墙法的墙，放到第一个盒子的最后。
   内墙法不仅能够让后部分的p不去追前部分的p了，并且能让第一个div根据儿子自动设置高度了.

     <div> 
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 	<div class="cl h10"></div>
	 </div>
	
	 <div> 
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>

 5.overflow:hidden
   这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是我们发现这个东西能够用于浮动的清除。
   我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden 那么这个父亲就能够被自己浮动的儿子撑出高度了。
   这个现象不能解释，就是浏览器的小偏方。
   并且voerflow:hidden 能够让 margin 生效
     .box1{
	    overflow: hidden;
	    margin-bottom: 10px;
     }

     <div class="box1"> 
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>
	
	 <div> 
	 	<p></p>
	 	<p></p>
	 	<p></p>
	 </div>























